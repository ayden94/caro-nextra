# 미들웨어 합성

reducer 미들웨어를 제외한 Caro-Kann의 다른 모든 미들웨어들은 **조건 없이 자유롭게 합성(composition)** 이 가능합니다. 이는 여러 미들웨어를 중첩하여 사용할 때, 각 미들웨어가 서로 간섭하지 않고 독립적으로 동작한다는 것을 의미합니다.

예를 들어, logger, validate, debounce 미들웨어를 함께 사용할 경우, 상태 변경은 먼저 validate를 통해 유효성이 검증되고, 이후 debounce로 최적화된 시점에 적용되며, 마지막으로 logger를 통해 콘솔에 로깅되는 방식으로 자연스러운 흐름이 보장됩니다. 이러한 미들웨어 합성은 개발자가 다양한 기능을 유연하게 조합하여 상태 관리의 정확성과 성능을 동시에 확보할 수 있도록 돕습니다.

다른 미들웨어들과 달리, reducer 미들웨어는 오직 create 함수 바로 아래에만 위치할 수 있습니다. 이는 reducer가 setState 대신 dispatch를 반환하기 때문입니다.

```tsx
const useStore = create(
  reducer(
    (store, { type, payload = 1 }: { type: string, payload?: number }) => {
      switch (type) {
        case "INCREMENT":
          return { count: store.count + payload };
        case "DECREMENT":
          return { count: store.count - payload };
        default:
          return store;
      }
    },
    persist(
      devtools(
        { count: 0 },
        "devtoolsTestStore"
      ),
      { local: "count" }
    )
  )
);

export default function Page() {
  const [count, dispatch] = useStore(store => store.count)
 
  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => dispatch({ type: "INCREMENT", payload: 2 })}>Increment</button>
      <button onClick={() => dispatch({ type: "DECREMENT" })}>Decrement</button>
    </div>
  )
}
```
