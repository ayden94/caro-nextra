# Middleware Composition

All of Caro-Kann's middleware, except for the reducer middleware, can be freely composed without any conditions. This means that when multiple middlewares are used together, each middleware operates independently without interfering with each other.

For example, when using the logger, validate, and debounce middlewares together, the state change is first validated through validate, then optimized by debounce at the appropriate time, and finally logged to the console via logger, ensuring a smooth flow. This composition of middlewares helps developers combine various functionalities flexibly, ensuring both the accuracy of state management and the performance of the application.

Unlike other middlewares, the reducer middleware must be placed immediately below the create function. This is because the reducer returns dispatch instead of setState.

```tsx
const useStore = create(
  reducer(
    (store, { type, payload = 1 }: { type: string, payload?: number }) => {
      switch (type) {
        case "INCREMENT":
          return { count: store.count + payload };
        case "DECREMENT":
          return { count: store.count - payload };
        default:
          return store;
      }
    },
    persist(
      devtools(
        { count: 0 },
        "devtoolsTestStore"
      ),
      { local: "count" }
    )
  )
);

export default function Page() {
  const [count, dispatch] = useStore(store => store.count)
 
  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => dispatch({ type: "INCREMENT", payload: 2 })}>Increment</button>
      <button onClick={() => dispatch({ type: "DECREMENT" })}>Decrement</button>
    </div>
  )
}
```
